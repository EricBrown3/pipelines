{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\r\n * Data for executing a stage.\r\n */\r\ninterface StageData<\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * should execute this pass?\r\n   */\r\n  shouldExecute: (\r\n    params: TParams,\r\n  ) => boolean;\r\n  /**\r\n   * Execute this pass.\r\n   */\r\n  doExecute: (\r\n    params: TParams,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Data for executing a stage within a pipeline.\r\n */\r\ninterface PipelineStageData<\r\n  TPipelineParams,\r\n  TStageParams,\r\n  TStageResult,\r\n> extends StageData<TStageParams, TStageResult> {\r\n  /**\r\n   * Produce params for this stage.\r\n   */\r\n  readonly produceParams: (\r\n    pipelineParams: TPipelineParams,\r\n  ) => TStageParams;\r\n\r\n  /**\r\n   * Before executing any stage.\r\n   */\r\n  readonly beforeExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TStageParams,\r\n  ) => void;\r\n\r\n  /**\r\n   * After executing any stage.\r\n   * Invoked when {@link shouldExecute} returns `false`.\r\n   * @param result return of `doExecute`. `void` when `shouldExecute` returned `false`.\r\n   */\r\n  readonly afterExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TStageParams,\r\n    result: TStageResult | void,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Data for executing a pipeline.\r\n * @template TPassParams base type of stage params.\r\n * @template TPassResult base type of stage results.\r\n */\r\ninterface PipelineData<\r\n  TParams,\r\n  TResult,\r\n  TPassParams,\r\n  TPassResult,\r\n> {\r\n  /**\r\n   * Stages to execute.\r\n   */\r\n  readonly stageDatas: Array<\r\n    | PipelineStageData<TParams, TPassParams, TPassResult>\r\n  >;\r\n\r\n  /**\r\n   * Produce this pipeline's results.\r\n   */\r\n  readonly produceResults: (\r\n    params: TParams,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Execute a pipeline.\r\n * Passes {@link StageResult.nextStageParams} of each stage into the `params` of the next stage.\r\n * @param params passed to the initial stage.\r\n * @returns results of the last stage.\r\n */\r\nfunction executePipeline<\r\n  TParams,\r\n  TResult,\r\n  TPassParams,\r\n  TPassResult,\r\n>(\r\n  data: PipelineData<\r\n    TParams,\r\n    TResult,\r\n    TPassParams,\r\n    TPassResult\r\n  >,\r\n  params: TParams,\r\n): TResult {\r\n  for (\r\n    let iStageOrderIndex = 0;\r\n    iStageOrderIndex < data.stageDatas.length;\r\n    iStageOrderIndex++\r\n  ) {\r\n    const iStageData = data.stageDatas[iStageOrderIndex];\r\n\r\n    if (iStageData === undefined) {\r\n      throw new Error(`Missing data!`);\r\n    }\r\n\r\n    const iStageParams = iStageData.produceParams(\r\n      params,\r\n    );\r\n\r\n    iStageData.beforeExecute?.(\r\n      params,\r\n      iStageParams,\r\n    );\r\n\r\n    let iShouldExecute = iStageData.shouldExecute(\r\n      iStageParams,\r\n    );\r\n\r\n    let iStageResult;\r\n    if (iShouldExecute === true) {\r\n      iStageResult = iStageData.doExecute(\r\n        iStageParams,\r\n      );\r\n    }\r\n\r\n    (iStageData as PipelineStageData<\r\n      TParams,\r\n      TPassParams,\r\n      TPassResult\r\n    >).afterExecute?.(\r\n      params,\r\n      iStageParams,\r\n      iStageResult,\r\n    );\r\n  }\r\n\r\n  // produce results\r\n  return data.produceResults(\r\n    params,\r\n  );\r\n}\r\n\r\nexport { executePipeline, type StageData as StageData, type PipelineData };\r\n"],"mappings":";AAwFA,SAAS,gBAMP,MAMA,QACS;AACT,WACM,mBAAmB,GACvB,mBAAmB,KAAK,WAAW,QACnC,oBACA;AACA,UAAM,aAAa,KAAK,WAAW,gBAAgB;AAEnD,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI,MAAM,eAAe;AAAA,IACjC;AAEA,UAAM,eAAe,WAAW;AAAA,MAC9B;AAAA,IACF;AAEA,eAAW;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAEA,QAAI,iBAAiB,WAAW;AAAA,MAC9B;AAAA,IACF;AAEA,QAAI;AACJ,QAAI,mBAAmB,MAAM;AAC3B,qBAAe,WAAW;AAAA,QACxB;AAAA,MACF;AAAA,IACF;AAEA,IAAC,WAIE;AAAA,MACD;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,SAAO,KAAK;AAAA,IACV;AAAA,EACF;AACF;","names":[]}