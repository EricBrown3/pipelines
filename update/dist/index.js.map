{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\r\n * Data for executing a stage.\r\n */\r\ninterface StageData<\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * Execute this stage.\r\n   */\r\n  doExecute: (\r\n    params: TParams,\r\n  ) => TResult | void;\r\n}\r\n\r\n/**\r\n * Data for executing a stage within a pipeline.\r\n */\r\ninterface PipelineStageData<\r\n  TPipelineParams,\r\n  TPipelineStageResult,\r\n  TStageParams,\r\n  TStageResult,\r\n> extends StageData<TStageParams, TStageResult> {\r\n  /**\r\n   * Produce params for this stage.\r\n   * @param pipelineStageResults current results of the stage pipeline.\r\n   */\r\n  readonly produceParams: (\r\n    pipelineParams: TPipelineParams,\r\n    pipelineStageResults: Record<number, TPipelineStageResult | void>,\r\n  ) => TStageParams;\r\n\r\n  /**\r\n   * should execute this stage?\r\n   */\r\n  shouldExecute?:\r\n    | boolean\r\n    | ((\r\n      params: TStageParams,\r\n      pipelineStageResults: Record<number, TPipelineStageResult | void>,\r\n    ) => boolean);\r\n\r\n  /**\r\n   * Before executing any stage.\r\n   */\r\n  readonly beforeExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TStageParams,\r\n  ) => void;\r\n\r\n  /**\r\n   * After executing any stage.\r\n   * Invoked when {@link shouldExecute} returns `false`.\r\n   * @param result return of `doExecute`. `void` when `shouldExecute` returned `false`.\r\n   */\r\n  readonly afterExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TStageParams,\r\n    result: TStageResult | void,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Data for executing a pipeline.\r\n * @template TStageParams base type of stage params.\r\n * @template TStageResult base type of stage results.\r\n */\r\ninterface PipelineData<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n> {\r\n  /**\r\n   * Stages to execute.\r\n   */\r\n  readonly stageDatas: Array<\r\n    PipelineStageData<TParams, TStageResult, TStageParams, TStageResult>\r\n  >;\r\n\r\n  /**\r\n   * Produce this pipeline's results.\r\n   */\r\n  readonly produceResults?: (\r\n    params: TParams,\r\n    results: Record<number, TStageResult | void>,\r\n  ) => TResult;\r\n}\r\n\r\nfunction shouldExecutePipelineStage<\r\n  TPipelineParams,\r\n  TPipelineStageResult,\r\n  TStageParams,\r\n  TStageResult,\r\n>(\r\n  iStageData: PipelineStageData<\r\n    TPipelineParams,\r\n    TPipelineStageResult,\r\n    TStageParams,\r\n    TStageResult\r\n  >,\r\n  iStageParams: TStageParams,\r\n  pipelineStageResults: Record<number, TPipelineStageResult | void>,\r\n) {\r\n  switch (typeof iStageData.shouldExecute) {\r\n    case \"boolean\":\r\n      return iStageData.shouldExecute;\r\n    case \"function\":\r\n      return iStageData.shouldExecute(iStageParams, pipelineStageResults);\r\n    default:\r\n      return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Execute a pipeline.\r\n * Stagees {@link StageResult.nextStageParams} of each stage into the `params` of the next stage.\r\n * @param params stageed to the initial stage.\r\n * @returns results of the last stage.\r\n */\r\nfunction executePipeline<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n>(\r\n  data: PipelineData<\r\n    TParams,\r\n    TResult,\r\n    TStageParams,\r\n    TStageResult\r\n  >,\r\n  params: TParams,\r\n): TResult | void {\r\n  let stageResults: Record<number, TStageResult | void> = {};\r\n  for (\r\n    let iStageOrderIndex = 0;\r\n    iStageOrderIndex < data.stageDatas.length;\r\n    iStageOrderIndex++\r\n  ) {\r\n    const iStageData = data.stageDatas[iStageOrderIndex];\r\n\r\n    if (iStageData === undefined) {\r\n      throw new Error(`Missing data!`);\r\n    }\r\n\r\n    const iStageParams = iStageData.produceParams(\r\n      params,\r\n      stageResults,\r\n    );\r\n\r\n    iStageData.beforeExecute?.(\r\n      params,\r\n      iStageParams,\r\n    );\r\n\r\n    let iStageResult;\r\n    if (\r\n      shouldExecutePipelineStage(\r\n        iStageData,\r\n        iStageParams,\r\n        stageResults,\r\n      )\r\n    ) {\r\n      iStageResult = iStageData.doExecute(\r\n        iStageParams,\r\n      );\r\n\r\n      stageResults[iStageOrderIndex] = iStageResult;\r\n    }\r\n\r\n    iStageData.afterExecute?.(\r\n      params,\r\n      iStageParams,\r\n      iStageResult,\r\n    );\r\n  }\r\n\r\n  // produce results\r\n  if (data.produceResults !== undefined) {\r\n    return data.produceResults(\r\n      params,\r\n      stageResults,\r\n    );\r\n  } else {\r\n    return;\r\n  }\r\n}\r\n\r\nexport {\r\n  executePipeline,\r\n  type PipelineData,\r\n  shouldExecutePipelineStage,\r\n  type StageData as StageData,\r\n};\r\n"],"mappings":";AA0FA,SAAS,2BAMP,YAMA,cACA,sBACA;AACA,UAAQ,OAAO,WAAW,eAAe;AAAA,IACvC,KAAK;AACH,aAAO,WAAW;AAAA,IACpB,KAAK;AACH,aAAO,WAAW,cAAc,cAAc,oBAAoB;AAAA,IACpE;AACE,aAAO;AAAA,EACX;AACF;AAQA,SAAS,gBAMP,MAMA,QACgB;AAChB,MAAI,eAAoD,CAAC;AACzD,WACM,mBAAmB,GACvB,mBAAmB,KAAK,WAAW,QACnC,oBACA;AACA,UAAM,aAAa,KAAK,WAAW,gBAAgB;AAEnD,QAAI,eAAe,QAAW;AAC5B,YAAM,IAAI,MAAM,eAAe;AAAA,IACjC;AAEA,UAAM,eAAe,WAAW;AAAA,MAC9B;AAAA,MACA;AAAA,IACF;AAEA,eAAW;AAAA,MACT;AAAA,MACA;AAAA,IACF;AAEA,QAAI;AACJ,QACE;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,IACF,GACA;AACA,qBAAe,WAAW;AAAA,QACxB;AAAA,MACF;AAEA,mBAAa,gBAAgB,IAAI;AAAA,IACnC;AAEA,eAAW;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,MAAI,KAAK,mBAAmB,QAAW;AACrC,WAAO,KAAK;AAAA,MACV;AAAA,MACA;AAAA,IACF;AAAA,EACF,OAAO;AACL;AAAA,EACF;AACF;","names":[]}