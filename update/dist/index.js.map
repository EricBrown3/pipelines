{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\r\n * Data for executing a stage.\r\n */\r\ninterface PassData<\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * should execute this pass?\r\n   */\r\n  shouldExecute: (\r\n    params: TParams,\r\n  ) => boolean;\r\n  /**\r\n   * Execute this pass.\r\n   */\r\n  doExecute: (\r\n    params: TParams,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Data for executing a stage with multiple passes.\r\n */\r\ninterface MultiPassStageData<\r\n  TPipelineParams,\r\n  TPassParams,\r\n  TPassResult,\r\n> extends PassData<TPassParams, TPassResult> {\r\n  readonly passData: Array<PassData<TPassParams, TPassResult>>;\r\n\r\n  /**\r\n   * Produce params for all passes in this stage.\r\n   */\r\n  readonly produceParams: (\r\n    pipelineParams: TPipelineParams,\r\n  ) => TPassParams;\r\n\r\n  /**\r\n   * Before executing pass(es).\r\n   */\r\n  readonly beforeExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TPassParams,\r\n  ) => void;\r\n\r\n  /**\r\n   * After executing pass(es).\r\n   * Invoked when {@link shouldExecute} returns `false`.\r\n   * @param results return of `doExecute`. `void` when `shouldExecute` returned `false`.\r\n   */\r\n  readonly afterExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TPassParams,\r\n    results: Array<TPassResult | void>,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Data for executing a stage with a single pass.\r\n */\r\ninterface SinglePassStageData<\r\n  TPipelineParams,\r\n  TPassParams,\r\n  TPassResult,\r\n> {\r\n  readonly passData: PassData<TPassParams, TPassResult>;\r\n\r\n  /**\r\n   * Produce params for this stage.\r\n   */\r\n  readonly produceParams: (\r\n    pipelineParams: TPipelineParams,\r\n  ) => TPassParams;\r\n\r\n  /**\r\n   * Before executing any stage.\r\n   */\r\n  readonly beforeExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TPassParams,\r\n  ) => void;\r\n\r\n  /**\r\n   * After executing any stage.\r\n   * Invoked when {@link shouldExecute} returns `false`.\r\n   * @param result return of `doExecute`. `void` when `shouldExecute` returned `false`.\r\n   */\r\n  readonly afterExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TPassParams,\r\n    result: TPassResult | void,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Data for executing a pipeline.\r\n * @template TPassParams base type of stage params.\r\n * @template TPassResult base type of stage results.\r\n */\r\ninterface PipelineData<\r\n  TParams,\r\n  TResult,\r\n  TPassParams,\r\n  TPassResult,\r\n> {\r\n  /**\r\n   * Stages to execute.\r\n   */\r\n  readonly stageDatas: Array<\r\n    | SinglePassStageData<TParams, TPassParams, TPassResult>\r\n    | MultiPassStageData<TParams, TPassParams, TPassResult>\r\n  >;\r\n\r\n  /**\r\n   * Produce this pipeline's results.\r\n   */\r\n  readonly produceResults: (\r\n    params: TParams,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Execute a pipeline.\r\n * Passes {@link StageResult.nextStageParams} of each stage into the `params` of the next stage.\r\n * @param params passed to the initial stage.\r\n * @returns results of the last stage.\r\n */\r\nfunction executePipeline<\r\n  TParams,\r\n  TResult,\r\n  TPassParams,\r\n  TPassResult,\r\n>(\r\n  data: PipelineData<\r\n    TParams,\r\n    TResult,\r\n    TPassParams,\r\n    TPassResult\r\n  >,\r\n  params: TParams,\r\n): TResult {\r\n  for (\r\n    let iStageOrderIndex = 0;\r\n    iStageOrderIndex < data.stageDatas.length;\r\n    iStageOrderIndex++\r\n  ) {\r\n    const iPipelineStageData = data.stageDatas[iStageOrderIndex];\r\n\r\n    if (iPipelineStageData === undefined) {\r\n      throw new Error(`Missing data!`);\r\n    }\r\n\r\n    if (Array.isArray(iPipelineStageData.passData)) { // stage group\r\n      let iStageResults = new Array<TPassResult | void>(\r\n        iPipelineStageData.passData.length,\r\n      );\r\n\r\n      const iStageParams = iPipelineStageData.produceParams(\r\n        params,\r\n      );\r\n\r\n      iPipelineStageData.beforeExecute?.(\r\n        params,\r\n        iStageParams,\r\n      );\r\n\r\n      const iStages = iPipelineStageData.passData;\r\n      for (\r\n        let jStageGroupIndex = 0;\r\n        jStageGroupIndex < iStages.length;\r\n        jStageGroupIndex++\r\n      ) {\r\n        const jStageData = iStages[jStageGroupIndex];\r\n\r\n        if (jStageData === undefined) {\r\n          throw new Error(`Missing data!`);\r\n        }\r\n\r\n        const jShouldExecute = jStageData.shouldExecute(\r\n          iStageParams,\r\n        );\r\n\r\n        if (jShouldExecute === true) {\r\n          iStageResults[jStageGroupIndex] = jStageData.doExecute(\r\n            iStageParams,\r\n          );\r\n        }\r\n      }\r\n\r\n      (iPipelineStageData as MultiPassStageData<\r\n        TParams,\r\n        TPassParams,\r\n        TPassResult\r\n      >)\r\n        .afterExecute?.(\r\n          params,\r\n          iStageParams,\r\n          iStageResults,\r\n        );\r\n    } else { // stage solo\r\n      const iStageParams = iPipelineStageData.produceParams(\r\n        params,\r\n      );\r\n\r\n      iPipelineStageData.beforeExecute?.(\r\n        params,\r\n        iStageParams,\r\n      );\r\n\r\n      const iStageData = iPipelineStageData.passData;\r\n\r\n      let iShouldExecute = iStageData.shouldExecute(\r\n        iStageParams,\r\n      );\r\n\r\n      let iStageResult;\r\n      if (iShouldExecute === true) {\r\n        iStageResult = iStageData.doExecute(\r\n          iStageParams,\r\n        );\r\n      }\r\n\r\n      (iPipelineStageData as SinglePassStageData<\r\n        TParams,\r\n        TPassParams,\r\n        TPassResult\r\n      >).afterExecute?.(\r\n        params,\r\n        iStageParams,\r\n        iStageResult,\r\n      );\r\n    }\r\n  }\r\n\r\n  // produce results\r\n  return data.produceResults(\r\n    params,\r\n  );\r\n}\r\n\r\nexport { executePipeline, type PassData as StageData, type PipelineData };\r\n"],"mappings":";AAgIA,SAAS,gBAMP,MAMA,QACS;AACT,WACM,mBAAmB,GACvB,mBAAmB,KAAK,WAAW,QACnC,oBACA;AACA,UAAM,qBAAqB,KAAK,WAAW,gBAAgB;AAE3D,QAAI,uBAAuB,QAAW;AACpC,YAAM,IAAI,MAAM,eAAe;AAAA,IACjC;AAEA,QAAI,MAAM,QAAQ,mBAAmB,QAAQ,GAAG;AAC9C,UAAI,gBAAgB,IAAI;AAAA,QACtB,mBAAmB,SAAS;AAAA,MAC9B;AAEA,YAAM,eAAe,mBAAmB;AAAA,QACtC;AAAA,MACF;AAEA,yBAAmB;AAAA,QACjB;AAAA,QACA;AAAA,MACF;AAEA,YAAM,UAAU,mBAAmB;AACnC,eACM,mBAAmB,GACvB,mBAAmB,QAAQ,QAC3B,oBACA;AACA,cAAM,aAAa,QAAQ,gBAAgB;AAE3C,YAAI,eAAe,QAAW;AAC5B,gBAAM,IAAI,MAAM,eAAe;AAAA,QACjC;AAEA,cAAM,iBAAiB,WAAW;AAAA,UAChC;AAAA,QACF;AAEA,YAAI,mBAAmB,MAAM;AAC3B,wBAAc,gBAAgB,IAAI,WAAW;AAAA,YAC3C;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAEA,MAAC,mBAKE;AAAA,QACC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACJ,OAAO;AACL,YAAM,eAAe,mBAAmB;AAAA,QACtC;AAAA,MACF;AAEA,yBAAmB;AAAA,QACjB;AAAA,QACA;AAAA,MACF;AAEA,YAAM,aAAa,mBAAmB;AAEtC,UAAI,iBAAiB,WAAW;AAAA,QAC9B;AAAA,MACF;AAEA,UAAI;AACJ,UAAI,mBAAmB,MAAM;AAC3B,uBAAe,WAAW;AAAA,UACxB;AAAA,QACF;AAAA,MACF;AAEA,MAAC,mBAIE;AAAA,QACD;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,SAAO,KAAK;AAAA,IACV;AAAA,EACF;AACF;","names":[]}