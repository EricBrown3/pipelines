{"version":3,"sources":["../src/async.ts","../src/base.ts","../src/sync.ts"],"sourcesContent":["import PLazy from \"p-lazy\";\r\n\r\nimport {\r\n  BasePipelineData,\r\n  getOrderedStageEntries,\r\n  PipelineStageData,\r\n} from \"./base\";\r\n\r\n/**\r\n * Data for an an asynchronous stage.\r\n * @template TParams type of `params` passed to this stage.\r\n * @template TResult type of `result` returned from this stage.\r\n */\r\ninterface AsyncStageData<\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * Execute this stage.\r\n   * @param params used to execute this stage.\r\n   * @returns result of executing this stage.\r\n   */\r\n  doExecute: (\r\n    params: TParams,\r\n  ) => Promise<TResult>;\r\n}\r\n\r\n/**\r\n * Data for an asynchronous stage within a pipeline.\r\n */\r\ntype AsyncPipelineStageData<TParams, TStageParams, TStageResult> =\r\n  & PipelineStageData<TParams, TStageResult, TStageParams, TStageResult>\r\n  & AsyncStageData<TStageParams, TStageResult>;\r\n\r\n/**\r\n * Data for an asynchronous pipeline.\r\n * @template TParams Type of params for this pipeline.\r\n * @template TResult Type of results of this pipeline.\r\n * @template TStageParams base type of stage params.\r\n * @template TStageResult base type of stage results.\r\n */\r\ninterface AsyncPipelineData<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n> extends BasePipelineData<TParams, TResult, TStageParams, TStageResult> {\r\n  /**\r\n   * Stages to execute, in order,\r\n   */\r\n  readonly stageDatas:\r\n    | Record<\r\n      string,\r\n      AsyncPipelineStageData<TParams, TStageParams, TStageResult>\r\n    >\r\n    | Array<\r\n      AsyncPipelineStageData<TParams, TStageParams, TStageResult>\r\n    >;\r\n}\r\n\r\nenum ConcurrencyMode {\r\n  all,\r\n  any,\r\n  order,\r\n}\r\n\r\n/**\r\n * Execute an asynchronous pipeline.\r\n * @param order order to execute stages in. If `undefined`, the order of the keys of the pipeline's stage datas is used.\r\n * @param concurrencyMode concurrency mode\r\n * @returns return of {@link PipelineData.createResults}. `undefined` when {@link PipelineData.createResults} is `undefined`.\r\n */\r\nasync function executeAsyncPipeline<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n>(\r\n  data: AsyncPipelineData<\r\n    TParams,\r\n    TResult,\r\n    TStageParams,\r\n    TStageResult\r\n  >,\r\n  params: TParams,\r\n  concurrencyMode: ConcurrencyMode,\r\n  order?: Array<number> | Array<string>,\r\n): Promise<TResult | undefined> {\r\n  let stageResults: Record<string, TStageResult> = {};\r\n  const orderedStageDataEntries = getOrderedStageEntries(\r\n    data.stageDatas,\r\n    order,\r\n  );\r\n\r\n  const stageDataEntryPromises = orderedStageDataEntries.map(\r\n    ([iStageDataKey, iStageDataValue]) => {\r\n      return new PLazy<void>(\r\n        async () => {\r\n          const iStageParams: TStageParams = iStageDataValue.createParams(\r\n            params,\r\n            stageResults,\r\n          );\r\n\r\n          const iStageShouldExecute: boolean = iStageDataValue.shouldExecute?.(\r\n            iStageParams,\r\n            stageResults,\r\n          ) ?? true;\r\n\r\n          iStageDataValue.beforeExecute?.(\r\n            params,\r\n            iStageParams,\r\n            iStageShouldExecute,\r\n          );\r\n\r\n          let iStageResult: TStageResult | null = null;\r\n          if (\r\n            iStageShouldExecute\r\n          ) {\r\n            iStageResult = await iStageDataValue.doExecute(\r\n              iStageParams,\r\n            );\r\n\r\n            stageResults[iStageDataKey] = iStageResult;\r\n          }\r\n\r\n          iStageDataValue.afterExecute?.(\r\n            params,\r\n            iStageParams,\r\n            iStageResult,\r\n            iStageShouldExecute,\r\n          );\r\n        },\r\n      );\r\n    },\r\n  );\r\n\r\n  switch (concurrencyMode) {\r\n    case ConcurrencyMode.all:\r\n      await Promise.all(stageDataEntryPromises);\r\n      break;\r\n    case ConcurrencyMode.any:\r\n      await Promise.any(stageDataEntryPromises);\r\n      break;\r\n    case ConcurrencyMode.order:\r\n      for (const i of stageDataEntryPromises) {\r\n        await i;\r\n      }\r\n      break;\r\n    default:\r\n      throw new Error(`Not implemented! Mode '${concurrencyMode}'.`);\r\n  }\r\n\r\n  return data.createResults?.(\r\n    params,\r\n    stageResults,\r\n  );\r\n}\r\n\r\nexport {\r\n  type AsyncPipelineData,\r\n  type AsyncPipelineStageData,\r\n  type AsyncStageData,\r\n  ConcurrencyMode,\r\n  executeAsyncPipeline,\r\n};\r\n","/**\r\n * Data for executing a stage within a pipeline.\r\n * @template TPipelineParams params passed to {@link executePipeline}.\r\n * @template TPipelineStageResult result returned from {@link executePipeline}.\r\n * @template TParams type of `params` passed to this stage.\r\n * @template TResult type of `result` returned from this stage.\r\n */\r\ninterface PipelineStageData<\r\n  TPipelineParams,\r\n  TPipelineStageResult,\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * Create `params` for this stage.\r\n   * @param params Type of `params` for the pipeline of this stage. ie, passed to {@link executePipeline}.\r\n   * @param stageResults Return of {@link StageData.doExecute} of other stages in this pipeline.\r\n   * @returns Params passed to all functions of this stage.\r\n   */\r\n  readonly createParams: (\r\n    params: TPipelineParams,\r\n    stageResults: Record<string, TPipelineStageResult>,\r\n  ) => TParams;\r\n\r\n  /**\r\n   * Should execute this stage?\r\n   * @param params Return of {@link createParams}.\r\n   * @param stageResults Return of {@link StageData.doExecute} of other stages in this pipeline.\r\n   * @return Should invoke {@link doExecute}?\r\n   */\r\n  readonly shouldExecute?: (\r\n    params: TParams,\r\n    stageResults: Record<string, TPipelineStageResult>,\r\n  ) => boolean;\r\n\r\n  /**\r\n   * Hook invoked before executing this stage.\r\n   * Always invoked (even when {@link shouldExecute} returns `false`).\r\n   * Invoked after {@link shouldExecute}, and before {@link StageData.doExecute}.\r\n   * @param pipelineParams params passed to {@link executePipeline}.\r\n   * @param params Return of {@link createParams}.\r\n   * @param willExecute Will invoke {@link StageData.doExecute}? ie, return of {@link shouldExecute}.\r\n   */\r\n  readonly beforeExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TParams,\r\n    willExecute: boolean,\r\n  ) => void;\r\n\r\n  /**\r\n   * Hook invoked after executing this stage.\r\n   * Always invoked (even when {@link shouldExecute} returns `false`).\r\n   * @param pipelineParams Params for the pipeline of this stage. ie, passed to {@link executePipeline}.\r\n   * @param params Return of {@link createParams}.\r\n   * @param result Result of executing this stage, return of {@link StageData.doExecute}. `null` when `doExecute` was not invoked. ie, when `didExecute` is `false` and `shouldExecute` returned `false`.\r\n   * @param didExecute Did invoke {@link StageData.doExecute}? ie, return of {@link shouldExecute}.\r\n   */\r\n  readonly afterExecute?: (\r\n    pipelineParams: TPipelineParams,\r\n    params: TParams,\r\n    result: TResult | null,\r\n    didExecute: boolean,\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Data for executing a pipeline.\r\n * @template TParams Type of params for this pipeline.\r\n * @template TResult Type of results of this pipeline.\r\n * @template TStageParams base type of stage params.\r\n * @template TStageResult base type of stage results.\r\n */\r\ninterface BasePipelineData<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n> {\r\n  /**\r\n   * Stages to execute.\r\n   */\r\n  readonly stageDatas:\r\n    | Record<\r\n      string,\r\n      PipelineStageData<TParams, TStageResult, TStageParams, TStageResult>\r\n    >\r\n    | Array<\r\n      PipelineStageData<TParams, TStageResult, TStageParams, TStageResult>\r\n    >;\r\n\r\n  /**\r\n   * Create this pipeline's results.\r\n   * When `undefined`, {@link executePipeline} returns `undefined`.\r\n   * @param pipelineParams Params passed to this pipeline. ie, passed to {@link executePipeline}.\r\n   * @param pipelineStageResults Return of {@link StageData.doExecute} from other stages in this pipeline.\r\n   * @returns Used as return value for {@link executePipeline}.\r\n   */\r\n  readonly createResults?: (\r\n    pipelineParams: TParams,\r\n    pipelineStageResults: Record<number, TStageResult>,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Create a new array from entries of {@link stageDatas}, ordered by {@link order}.\r\n * @param order order of returned array. When `undefined`, the keys of {@link stageDatas} is used.\r\n * @param stageDatas stage datas to order.\r\n * @remarks\r\n * This function is generic.\r\n */\r\nfunction getOrderedStageDataEntries<\r\n  TStageData,\r\n>(\r\n  stageDatas: Record<string, TStageData> | Array<TStageData>,\r\n  order?: Array<string> | Array<number>,\r\n): Array<[string | number, TStageData]> {\r\n  if (Array.isArray(stageDatas)) {\r\n    order ??= [...stageDatas.keys()];\r\n  } else {\r\n    order ??= Object.keys(stageDatas);\r\n  }\r\n\r\n  const orderedStageEntries: Array<\r\n    [\r\n      string | number,\r\n      TStageData,\r\n    ]\r\n  > = order.map(\r\n    (iStageDataKey) => {\r\n      let iStageDataValue;\r\n      if (Array.isArray(stageDatas)) {\r\n        if (typeof iStageDataKey !== \"number\") {\r\n          throw new TypeError();\r\n        }\r\n\r\n        iStageDataValue = stageDatas[iStageDataKey];\r\n      } else {\r\n        iStageDataValue = stageDatas[iStageDataKey];\r\n      }\r\n\r\n      if (iStageDataValue === undefined) {\r\n        throw new Error(`Undefined! ${iStageDataKey}`);\r\n      }\r\n\r\n      return [\r\n        iStageDataKey,\r\n        iStageDataValue,\r\n      ];\r\n    },\r\n  );\r\n\r\n  return orderedStageEntries;\r\n}\r\n\r\nexport {\r\n  type BasePipelineData,\r\n  getOrderedStageDataEntries as getOrderedStageEntries,\r\n  type PipelineStageData,\r\n};\r\n","import {\r\n  BasePipelineData,\r\n  getOrderedStageEntries,\r\n  PipelineStageData,\r\n} from \"./base\";\r\n\r\n/**\r\n * Data for a synchronous stage.\r\n * @template TParams type of `params` passed to this stage.\r\n * @template TResult type of `result` returned from this stage.\r\n */\r\ninterface SyncStageData<\r\n  TParams,\r\n  TResult,\r\n> {\r\n  /**\r\n   * Execute this stage.\r\n   * @param params used to execute this stage.\r\n   * @returns result of executing this stage.\r\n   */\r\n  doExecute: (\r\n    params: TParams,\r\n  ) => TResult;\r\n}\r\n\r\n/**\r\n * Data for synchronous stage in a pipeline.\r\n */\r\ntype SyncPipelineStageData<TParams, TStageParams, TStageResult> =\r\n  & PipelineStageData<TParams, TStageResult, TStageParams, TStageResult>\r\n  & SyncStageData<TStageParams, TStageResult>;\r\n\r\n/**\r\n * Data for executing a synchronous pipeline.\r\n * @template TParams Type of params for this pipeline.\r\n * @template TResult Type of results of this pipeline.\r\n * @template TStageParams base type of stage params.\r\n * @template TStageResult base type of stage results.\r\n */\r\ninterface SyncPipelineData<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n> extends BasePipelineData<TParams, TResult, TStageParams, TStageResult> {\r\n  /**\r\n   * Stages to execute.\r\n   */\r\n  readonly stageDatas:\r\n    | Record<\r\n      string,\r\n      SyncPipelineStageData<TParams, TStageParams, TStageResult>\r\n    >\r\n    | Array<\r\n      SyncPipelineStageData<TParams, TStageParams, TStageResult>\r\n    >;\r\n}\r\n\r\n/**\r\n * Execute a pipeline.\r\n * @param order order to execute stages in. If `undefined`, the order of the keys of the pipeline's stage datas is used.\r\n * @returns return of {@link PipelineData.createResults}. `undefined` when {@link PipelineData.createResults} is `undefined`.\r\n */\r\nfunction executeSyncPipeline<\r\n  TParams,\r\n  TResult,\r\n  TStageParams,\r\n  TStageResult,\r\n>(\r\n  data: SyncPipelineData<\r\n    TParams,\r\n    TResult,\r\n    TStageParams,\r\n    TStageResult\r\n  >,\r\n  params: TParams,\r\n  order?: Array<number> | Array<string>,\r\n): TResult | undefined {\r\n  let stageResults: Record<string, TStageResult> = {};\r\n\r\n  const orderedStageDataEntries = getOrderedStageEntries(\r\n    data.stageDatas,\r\n    order,\r\n  );\r\n\r\n  for (\r\n    const [iStageDataKey, iStageDataValue] of orderedStageDataEntries\r\n  ) {\r\n    const iStageParams: TStageParams = iStageDataValue.createParams(\r\n      params,\r\n      stageResults,\r\n    );\r\n\r\n    const iStageShouldExecute: boolean = iStageDataValue.shouldExecute?.(\r\n      iStageParams,\r\n      stageResults,\r\n    ) ?? true;\r\n\r\n    iStageDataValue.beforeExecute?.(\r\n      params,\r\n      iStageParams,\r\n      iStageShouldExecute,\r\n    );\r\n\r\n    let iStageResult: TStageResult | null = null;\r\n    if (\r\n      iStageShouldExecute\r\n    ) {\r\n      iStageResult = iStageDataValue.doExecute(\r\n        iStageParams,\r\n      );\r\n\r\n      stageResults[iStageDataKey] = iStageResult;\r\n    }\r\n\r\n    iStageDataValue.afterExecute?.(\r\n      params,\r\n      iStageParams,\r\n      iStageResult,\r\n      iStageShouldExecute,\r\n    );\r\n  }\r\n\r\n  return data.createResults?.(\r\n    params,\r\n    stageResults,\r\n  );\r\n}\r\n\r\nexport {\r\n  executeSyncPipeline,\r\n  type SyncPipelineData,\r\n  type SyncPipelineStageData,\r\n  type SyncStageData,\r\n};\r\n"],"mappings":"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","names":["ConcurrencyMode"]}